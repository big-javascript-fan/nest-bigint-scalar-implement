# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Auth {
  """JWT access token"""
  accessToken: String!

  """JWT refresh token"""
  refreshToken: String!
  user: User!
}

input AuthByWalletInput {
  network: String = "mumbai"
  signature: String!
  wallet: String!
}

input CreateEstateInput {
  buyerWalletAddress: String
  chainId: Int!
  nftId: Int!
  sellerDeadline: Date!
  sellerPrice: Int!
  sellerWalletAddress: String!
  signature: String!
  status: Int
  tokenAddress: String!
  type: Int!
}

"""Date custom scalar type"""
scalar Date

type Estate {
  """Identifies the date and time when the offer closed."""
  closedAt: Date

  """Identifies the date and time when the object was created."""
  createdAt: Date!

  """Identifies the date and time when the offer expire."""
  expireAt: Date
  id: Int!
  nft: Nft
  price: Float!
  seller: String!
  sellerSignature: String
  status: EstateStatus!
  tokenAddress: String
  tx: String
  type: EstateType!

  """Identifies the date and time when the object was last updated."""
  updatedAt: Date!
}

"""Possible offers statuses"""
enum EstateStatus {
  active
  finished
}

"""Offer or Sale"""
enum EstateType {
  offer
  sale
}

type Estates {
  estates: [Estate!]
  estatesCount: Int
}

input GetNonceByWalletInput {
  wallet: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  authByWallet(data: AuthByWalletInput!): Auth!
  createEstate(data: CreateEstateInput!): Estate!
  refreshToken(token: String!): Token!
  updateEstate(data: UpdateEstateInput!): Estate!
  updateNftMetadata(data: String, meta_id: Int): NftMetadata!
  updateSaleInfoJson(data: String, nftId: Int): Nft!
}

type Nft {
  """Identifies the date and time when the object was created."""
  createdAt: Date!
  estates: [Estate!]
  id: Int!
  isOnMarketplace: Boolean!
  lastSale: Date!
  nftMetadata: NftMetadata
  nftMetadataId: Int
  ownerWalletAddress: String
  saleInfo: JSON
  show: Boolean
  status: Int
  tokenId: String

  """Identifies the date and time when the object was last updated."""
  updatedAt: Date!
}

type NftMetadata {
  id: Int!
  metadata: JSON
}

type Nfts {
  nfts: [Nft!]
  nftsCount: Int
}

type Nonce {
  nonce: String!
}

input OrderByInput {
  created_at: String
  price: String
}

input PriceWhereInput {
  gt: Int!
  lt: Int!
}

type Query {
  findMyOffersBy(onePage: Int, orderBy: OrderByInput, page: Int, price: PriceWhereInput, searchText: String, status: Int, wallet: String): Estates!
  findNfts(limit: Int, onePage: Int, page: Int, searchText: String, sortList: String): Nfts!
  findOffersBy(onePage: Int, orderBy: OrderByInput, page: Int, price: PriceWhereInput, searchText: String, status: Int, wallet: String): Estates!
  findOffersByWalletAddress(type: Int!, wallet: String!): Estates!
  findSalesBy(onePage: Int, orderBy: OrderByInput, page: Int, price: PriceWhereInput, searchText: String, status: Int): Estates!
  findSalesByWalletAddress(wallet: String!): Estates!
  findUsers(limit: Int, onePage: Int, page: Int, sortList: String): Users!
  getNftListByWallet(wallet: String!): Nfts!
  getNonceByWallet(data: GetNonceByWalletInput!): Nonce!
  me: User!
  nft(id: Int): Nft!
  offer(id: Int): Estate!
  user(id: Int, walletAddress: String): User!
}

type Token {
  """JWT access token"""
  accessToken: String!

  """JWT refresh token"""
  refreshToken: String!
}

input UpdateEstateInput {
  chainId: Int!
  id: Int!
  nftId: Int!
  sellerDeadline: Date!
  sellerPrice: Int!
  sellerWalletAddress: String!
  signature: String!
  status: Int
  tokenAddress: String!
}

type User {
  id: Int!
  lastSignAt: Date!
  nonce: String
  status: Int
  walletAddress: String!
}

type Users {
  users: [User!]
  usersCount: Int
}
